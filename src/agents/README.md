# AutoMCP Agents

AutoMCP (ITOES) 的核心智能体编排层，基于 **LangGraph** 实现了一个具备规划、执行、反思能力的自治系统。

## 目录结构与模块说明

该目录 (`src/agents/`) 包含了驱动 AutoMCP 智能行为的所有核心组件。

| 文件名 | 模块名称 | 职责描述 |
| :--- | :--- | :--- |
| `graph.py` | **Orchestration** | **总指挥**。定义了 StateGraph，连接所有节点，配置路由规则 (Edges) 和条件跳转。 |
| `state.py` | **Context** | **共享内存**。定义了 `AgentState` (TypedDict)，作为所有节点之间传递的上下文容器。 |
| `planner.py` | **Planner** | **大脑**。利用 LLM 将用户输入拆解为结构化的 JSON 任务列表 (`ExecutionPlan`)。 |
| `classifier.py` | **Classifier** | **分拣员**。使用微调小模型 (SLM) 将子任务分类为 `local_mcp`, `web_mcp`, `code_to_mcp` 等。 |
| `router.py` | **Router** | **交通警**。根据分类结果，决定将任务分发给哪个执行节点 (Executor)。 |
| `executor.py` | **Executor** | **实干家**。基于 ReAct 模式，调用具体的 MCP 工具执行子任务，并返回结果。 |
| `reflection.py` | **Reflection** | **医生**。监控执行失败，提供两级反思机制（子任务级重试 & 任务级重规划）。 |

## 交互流程 (Workflow)

整个系统是一个有向循环图 (Directed Cyclic Graph)，主要数据流如下：

1.  **Input**: 用户输入自然语言任务。
2.  **Planner**: 生成任务列表 (`plan`) -> 写入 `AgentState`。
3.  **Classifier**: 读取当前步骤 (`current_step`) -> 打上分类标签 (`task_type`)。
4.  **Router**: 读取分类标签 -> 路由至对应的执行器。
5.  **Executor**:
    *   **执行**: 调用 MCP 工具。
    *   **成功**: 更新结果，指针 (`idx`) +1 -> 回到 **Classifier** 处理下一步。
    *   **失败**: 标记状态为 Failed -> 路由至 **Reflection**。
6.  **Reflection**:
    *   **Level 1 (微修)**: 分析错误，更新子任务描述 -> 回到 **Classifier** 重试。
    *   **Level 2 (重构)**: 如果重试耗尽，回退到 **Planner** 重新规划。

## 关键特性

*   **分形架构**: AutoMCP 本身是一个 MCP Server，其内部又通过 MCP Client 调用其他工具。
*   **混合智能**:
    *   **Planner/Executor**: 使用大模型 (GPT-4o) 处理复杂逻辑。
    *   **Classifier**: 使用小模型 (Fine-tuned SLM) 处理高频分类，降低延迟与成本。
*   **鲁棒性**: 双层反思机制确保了系统在遇到错误时具有自我修复能力，而不是直接崩溃。

## 状态管理

所有节点共享同一个 `AgentState` 对象：

```python
class AgentState(TypedDict):
    messages: List[AgentMessage]  # 聊天记录
    plan: List[TaskStep]          # 任务队列
    current_step_index: int       # 当前进度指针
    reflection_count: int         # 反思计数器
```

---
*Generated by AutoMCP Architect Agent*
